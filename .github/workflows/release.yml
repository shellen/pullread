name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true

permissions:
  contents: write
  actions: write

jobs:
  build:
    runs-on: macos-latest
    env:
      HAS_SPARKLE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Create git tag (workflow_dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${VERSION}" -m "Release v${VERSION}"
          git push origin "v${VERSION}"

      - name: Install Bun
        uses: oven-sh/setup-bun@v2

      - name: Build PullRead CLI binary
        run: |
          # Install dependencies
          bun install

          # Embed viewer.html into the TypeScript source so the compiled
          # binary serves the viewer from memory (no external file needed)
          bun scripts/embed-viewer.ts

          # Build for both architectures
          bun build src/index.ts --compile --target=bun-darwin-arm64 --outfile dist/pullread-arm64
          bun build src/index.ts --compile --target=bun-darwin-x64 --outfile dist/pullread-x64

          # Create universal binary
          mkdir -p dist
          lipo -create dist/pullread-arm64 dist/pullread-x64 -output dist/pullread

          # Verify
          file dist/pullread

      - name: Install Apple certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

      - name: Sync models.json to Swift
        run: bun scripts/sync-swift-models.ts

      - name: Build app
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          # Compute build number: major*10000 + minor*100 + patch
          BUILD_NUMBER=$(echo "$VERSION" | awk -F. '{printf "%d", $1*10000+$2*100+$3}')
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          cd PullReadTray
          xcodebuild -project PullReadTray.xcodeproj \
            -scheme PullReadTray \
            -configuration Release \
            -derivedDataPath build \
            -destination 'platform=macOS' \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
            ENABLE_HARDENED_RUNTIME=YES \
            MARKETING_VERSION="$VERSION" \
            CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
            clean build

      - name: Bundle CLI binary into app
        run: |
          APP_PATH="PullReadTray/build/Build/Products/Release/Pull Read.app"
          RESOURCES_PATH="$APP_PATH/Contents/Resources"
          IDENTITY="Developer ID Application"

          # Copy binary to app resources
          cp dist/pullread "$RESOURCES_PATH/"

          # Re-sign all embedded frameworks for notarization.
          # Sparkle (via SPM) includes nested executables (Autoupdate, Updater.app,
          # Installer.xpc) that all need hardened runtime + secure timestamps.
          # Xcode's build-time signing may not apply these flags to SPM dependencies.
          # Sign from inside out: individual Mach-O binaries first, then bundles
          # from deepest to shallowest.
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            echo "Signing embedded frameworks..."

            # 1. Sign all Mach-O binaries inside Frameworks/
            find "$APP_PATH/Contents/Frameworks" -type f | while read -r f; do
              if file "$f" | grep -qE "Mach-O"; then
                echo "  Signing binary: $f"
                codesign --force --options runtime --timestamp \
                  --sign "$IDENTITY" "$f"
              fi
            done

            # 2. Sign all sub-bundles (.xpc, .app) deepest first, then .framework
            find "$APP_PATH/Contents/Frameworks" -depth \
              \( -name "*.xpc" -o -name "*.app" -o -name "*.framework" \) \
              -type d | while read -r bundle; do
              echo "  Signing bundle: $bundle"
              codesign --force --options runtime --timestamp \
                --sign "$IDENTITY" "$bundle"
            done
          fi

          # Sign the bundled CLI binary (hardened runtime + timestamp required for notarization)
          # disable-library-validation allows loading native addons (e.g. onnxruntime
          # for Kokoro TTS) that Bun extracts at runtime to a temp directory
          codesign --force --options runtime --timestamp \
            --sign "$IDENTITY" \
            --entitlements PullReadTray/cli-entitlements.plist \
            "$RESOURCES_PATH/pullread"

          # Sign the main app binary
          codesign --force --options runtime --timestamp \
            --sign "$IDENTITY" \
            "$APP_PATH/Contents/MacOS/Pull Read"

          # Sign the overall app bundle
          codesign --force --options runtime --timestamp \
            --sign "$IDENTITY" \
            "$APP_PATH"

          # Verify signing
          codesign -dv --verbose=2 "$APP_PATH"
          codesign -d --verbose=2 "$APP_PATH" 2>&1 | grep -i runtime

          # Verify all nested code is properly signed before notarization
          echo "Verifying all code signatures..."
          codesign --verify --deep --strict "$APP_PATH"
          echo "All signatures valid."

          # Free disk space: remove intermediate build artifacts
          rm -rf dist
          rm -rf PullReadTray/build/Build/Intermediates*

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        run: |
          APP_PATH="PullReadTray/build/Build/Products/Release/Pull Read.app"

          # Create ZIP for notarization
          ditto -c -k --keepParent "$APP_PATH" PullRead-app.zip

          # Submit for notarization and capture output
          SUBMIT_OUTPUT=$(xcrun notarytool submit PullRead-app.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --wait 2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Extract submission ID and check status
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')

          if echo "$SUBMIT_OUTPUT" | grep -q "status: Invalid"; then
            echo "::error::Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --team-id "$APPLE_TEAM_ID" \
              --password "$APPLE_ID_PASSWORD" \
              notarization-log.json
            cat notarization-log.json
            exit 1
          fi

          # Staple the ticket
          xcrun stapler staple "$APP_PATH"

          rm PullRead-app.zip

      - name: Create DMG
        run: |
          APP_PATH="PullReadTray/build/Build/Products/Release/Pull Read.app"

          # Create a temporary directory for DMG contents
          mkdir -p dmg-contents
          cp -R "$APP_PATH" dmg-contents/

          # Create a symlink to Applications for drag-to-install
          ln -s /Applications dmg-contents/Applications

          # Calculate source size with generous padding â€” hdiutil -srcfolder
          # underestimates for large Bun-compiled binaries, causing
          # "No space left on device" on the temp R/W volume
          SIZE_MB=$(du -sm dmg-contents | awk '{print int($1 * 1.5 + 30)}')
          echo "DMG source size with padding: ${SIZE_MB}MB"

          # Create the DMG (volume name shows as "Pull Read" to users)
          hdiutil create -volname "Pull Read" \
            -srcfolder dmg-contents \
            -ov -format UDZO \
            -size ${SIZE_MB}m \
            PullRead.dmg

          # Clean up
          rm -rf dmg-contents

          # Sign DMG
          codesign --force --sign "Developer ID Application" --timestamp PullRead.dmg

      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        run: |
          xcrun notarytool submit PullRead.dmg \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --wait

          xcrun stapler staple PullRead.dmg

      - name: Verify signature
        run: |
          echo "Verifying DMG..."
          codesign -dv --verbose=2 PullRead.dmg
          spctl -a -v --type open --context context:primary-signature PullRead.dmg

      - name: Sign DMG for Sparkle
        if: env.HAS_SPARKLE_KEY != ''
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          # Fetch latest Sparkle release tag dynamically to avoid hardcoded version mismatch
          SPARKLE_TAG=$(curl -s https://api.github.com/repos/sparkle-project/Sparkle/releases/latest | python3 -c "import sys,json; print(json.load(sys.stdin)['tag_name'])")
          echo "Downloading Sparkle ${SPARKLE_TAG}"
          curl -L -o Sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_TAG}/Sparkle-${SPARKLE_TAG}.tar.xz"
          mkdir -p sparkle-tools
          tar -xf Sparkle.tar.xz -C sparkle-tools

          # Sign the DMG with Sparkle's EdDSA signature
          # sign_update requires the key via -f flag (does not read from stdin)
          KEY_FILE=$(mktemp)
          echo "$SPARKLE_PRIVATE_KEY" > "$KEY_FILE"
          SIGNATURE=$(sparkle-tools/bin/sign_update PullRead.dmg -f "$KEY_FILE")
          rm -f "$KEY_FILE"
          echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          echo "Sparkle signature generated"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.VERSION }}
          name: Pull Read v${{ steps.version.outputs.VERSION }}
          files: PullRead.dmg
          draft: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Sparkle appcast
        if: env.HAS_SPARKLE_KEY != ''
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          DMG_SIZE=$(stat -f%z PullRead.dmg)
          DMG_URL="https://github.com/${{ github.repository }}/releases/download/v${VERSION}/PullRead.dmg"

          # Generate appcast.xml into site/ so it's served alongside the marketing page
          # sign_update outputs: sparkle:edSignature="..." length="..."
          # so we must NOT add a separate length attribute (duplicate attrs = invalid XML)
          cat > site/appcast.xml << APPCAST_EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Pull Read</title>
              <link>https://pullread.com</link>
              <description>Pull Read updates</description>
              <language>en</language>
              <item>
                <title>Version ${VERSION}</title>
                <sparkle:version>${BUILD_NUMBER}</sparkle:version>
                <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>13.0</sparkle:minimumSystemVersion>
                <pubDate>$(date -R)</pubDate>
                <enclosure url="${DMG_URL}"
                           type="application/octet-stream"
                           ${SPARKLE_SIGNATURE} />
              </item>
            </channel>
          </rss>
          APPCAST_EOF

          # Commit appcast.xml into site/ on main and trigger Pages deploy
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add site/appcast.xml
          git commit -m "Update appcast for v${VERSION}" || echo "No changes to commit"
          git push origin HEAD:main

      - name: Trigger site deploy
        if: env.HAS_SPARKLE_KEY != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # The appcast push above uses GITHUB_TOKEN, which does not trigger
          # other workflows. Explicitly dispatch the deploy workflow so the
          # updated appcast.xml goes live on pullread.com.
          gh workflow run deploy-site.yml --ref main

      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
