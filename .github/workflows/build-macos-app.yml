# ABOUTME: GitHub Actions workflow to build and test PullReadTray macOS app
# ABOUTME: Builds once, runs tests with built artifacts, creates .app bundle and .dmg

name: Build macOS App

on:
  push:
    branches: [main, 'claude/**']
    paths:
      - 'PullReadTray/**'
      - 'src/**'
      - 'viewer.html'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/build-macos-app.yml'
  pull_request:
    branches: [main]
    paths:
      - 'PullReadTray/**'
      - 'src/**'
      - 'viewer.html'
      - 'package.json'
      - 'package-lock.json'
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a release with the built app'
        required: false
        default: 'false'
        type: boolean
      skip_tests:
        description: 'Skip running tests'
        required: false
        default: 'false'
        type: boolean

jobs:
  build-and-test:
    runs-on: macos-14

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # For PRs, checkout the PR head commit (not the merge commit) to match push behavior
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      - name: Free disk space
        run: |
          # Remove large pre-installed tools we don't need
          sudo rm -rf /usr/local/lib/android || true
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /Library/Developer/CoreSimulator/Volumes/* || true
          sudo rm -rf /Library/Developer/CoreSimulator/Caches/* || true
          df -h .

      - name: Select Xcode version
        run: sudo xcode-select -s /Applications/Xcode_15.2.app/Contents/Developer

      - name: Install Bun
        uses: oven-sh/setup-bun@v2

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb', '**/package-lock.json') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Build PullRead CLI binary
        run: |
          bun install
          bun scripts/embed-viewer.ts

          # Only build arm64 on CI (runner is arm64). Universal binary built in release workflow.
          mkdir -p dist
          bun build src/index.ts --compile --target=bun-darwin-arm64 --outfile dist/pullread

          file dist/pullread

          # Free space: remove node_modules and bun cache immediately
          rm -rf node_modules

      - name: Check for signing secrets
        id: check-cert
        env:
          CERT: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          NOTARIZE_ID: ${{ secrets.APPLE_ID }}
        run: |
          if [ -n "$CERT" ]; then
            echo "has_cert=true" >> $GITHUB_OUTPUT
            echo "HAS_SIGNING_CERT=true" >> $GITHUB_ENV
          fi
          if [ -n "$NOTARIZE_ID" ]; then
            echo "has_notarize=true" >> $GITHUB_OUTPUT
            echo "HAS_NOTARIZE_CREDS=true" >> $GITHUB_ENV
          fi

      - name: Install Apple certificate
        if: steps.check-cert.outputs.has_cert == 'true'
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          echo "Creating keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Decode and validate certificate
          echo "Decoding certificate..."
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          echo "Certificate file size: $(wc -c < $RUNNER_TEMP/certificate.p12) bytes"

          # Verify the p12 is valid before importing
          echo "Verifying p12 file..."
          openssl pkcs12 -in $RUNNER_TEMP/certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -noout 2>&1 || {
            echo "::error::Failed to verify .p12 file. Check APPLE_CERTIFICATE_PASSWORD matches the export password."
            exit 1
          }

          # Import certificate
          echo "Importing certificate into keychain..."
          security import $RUNNER_TEMP/certificate.p12 \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

          # Verify the identity is available
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

      - name: Install xcpretty
        run: gem install xcpretty

      - name: Build release app (signed)
        if: env.HAS_SIGNING_CERT == 'true'
        working-directory: PullReadTray
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -o pipefail
          xcodebuild build-for-testing \
            -project PullReadTray.xcodeproj \
            -scheme PullReadTray \
            -configuration Release \
            -derivedDataPath build \
            -destination 'platform=macOS,arch=arm64' \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
            ENABLE_TESTABILITY=YES \
            2>&1 | xcpretty --color

      - name: Build release app (unsigned)
        if: env.HAS_SIGNING_CERT != 'true'
        working-directory: PullReadTray
        run: |
          # Single build: Release with testing enabled (satisfies both test and release needs)
          set -o pipefail
          xcodebuild build-for-testing \
            -project PullReadTray.xcodeproj \
            -scheme PullReadTray \
            -configuration Release \
            -derivedDataPath build \
            -destination 'platform=macOS,arch=arm64' \
            CODE_SIGNING_ALLOWED=NO \
            ENABLE_TESTABILITY=YES \
            2>&1 | xcpretty --color

      - name: Run unit tests (without rebuilding)
        if: github.event.inputs.skip_tests != 'true'
        continue-on-error: true  # Don't block build if tests fail/timeout
        working-directory: PullReadTray
        timeout-minutes: 5
        env:
          # Signal to test host app that we're running tests (prevents UI initialization)
          RUNNING_XCTEST: '1'
        run: |
          set -o pipefail
          xcodebuild test-without-building \
            -project PullReadTray.xcodeproj \
            -scheme PullReadTray \
            -configuration Release \
            -destination 'platform=macOS,arch=arm64' \
            -derivedDataPath build \
            -only-testing:PullReadTrayTests \
            -skip-testing:PullReadTrayTests/SyncServiceTests/testSyncCompletesWithResult \
            -skip-testing:PullReadTrayTests/SyncServiceTests/testSyncRetryFailedCompletesWithResult \
            -skip-testing:PullReadTrayTests/SyncServiceTests/testConfigPathPerformance \
            -skip-testing:PullReadTrayTests/SyncServiceTests/testOutputPathPerformance \
            -resultBundlePath TestResults \
            2>&1 | xcpretty --test --color

      - name: Upload test results
        if: always() && github.event.inputs.skip_tests != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: PullReadTray/TestResults
          retention-days: 7
          if-no-files-found: ignore

      - name: Create app bundle with CLI
        working-directory: PullReadTray
        run: |
          mkdir -p artifacts
          APP_PATH="build/Build/Products/Release/Pull Read.app"

          # Copy app to artifacts
          cp -R "$APP_PATH" artifacts/

          # Bundle CLI binary into app resources
          cp ../dist/pullread "artifacts/Pull Read.app/Contents/Resources/"

          # Verify
          ls -la "artifacts/Pull Read.app/Contents/Resources/"

          # Free disk space: remove everything we no longer need
          rm -rf ../dist
          rm -rf build
          df -h .

      - name: Sign app bundle
        if: env.HAS_SIGNING_CERT == 'true'
        working-directory: PullReadTray
        run: |
          APP_PATH="artifacts/Pull Read.app"
          IDENTITY="Developer ID Application"

          # Sign the bundled CLI binary (hardened runtime required for notarization)
          codesign --force --options runtime --timestamp \
            --sign "$IDENTITY" \
            "$APP_PATH/Contents/Resources/pullread"

          # Sign the main app binary
          codesign --force --options runtime --timestamp \
            --sign "$IDENTITY" \
            "$APP_PATH/Contents/MacOS/PullReadTray"

          # Sign the overall app bundle
          codesign --force --options runtime --timestamp \
            --sign "$IDENTITY" \
            "$APP_PATH"

          # Verify
          codesign -dv --verbose=2 "$APP_PATH"
          echo "Verifying hardened runtime flag..."
          codesign -d --verbose=2 "$APP_PATH" 2>&1 | grep -i runtime

      - name: Create DMG
        working-directory: PullReadTray
        run: |
          # Create a temporary directory for DMG contents
          mkdir -p dmg-contents
          cp -R "artifacts/Pull Read.app" dmg-contents/

          # Create a symlink to Applications
          ln -s /Applications dmg-contents/Applications

          # Create the DMG (volume name shows as "Pull Read" to users)
          hdiutil create -volname "Pull Read" \
            -srcfolder dmg-contents \
            -ov -format UDZO \
            artifacts/PullRead.dmg

          # Clean up
          rm -rf dmg-contents

      - name: Sign DMG
        if: env.HAS_SIGNING_CERT == 'true'
        working-directory: PullReadTray
        run: |
          codesign --force --sign "Developer ID Application" --timestamp artifacts/PullRead.dmg

      - name: Notarize app
        if: env.HAS_SIGNING_CERT == 'true' && env.HAS_NOTARIZE_CREDS == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        run: |
          APP_PATH="PullReadTray/artifacts/Pull Read.app"

          # Create ZIP for notarization
          ditto -c -k --keepParent "$APP_PATH" PullRead-app.zip

          # Submit for notarization and capture output
          SUBMIT_OUTPUT=$(xcrun notarytool submit PullRead-app.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --wait 2>&1) || true

          echo "$SUBMIT_OUTPUT"

          # Extract submission ID and check status
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')

          if echo "$SUBMIT_OUTPUT" | grep -q "status: Invalid"; then
            echo "::error::Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --team-id "$APPLE_TEAM_ID" \
              --password "$APPLE_ID_PASSWORD" \
              notarization-log.json
            cat notarization-log.json
            exit 1
          fi

          # Staple the ticket
          xcrun stapler staple "$APP_PATH"
          rm PullRead-app.zip

      - name: Notarize DMG
        if: env.HAS_SIGNING_CERT == 'true' && env.HAS_NOTARIZE_CREDS == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        run: |
          xcrun notarytool submit PullReadTray/artifacts/PullRead.dmg \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --wait

          xcrun stapler staple PullReadTray/artifacts/PullRead.dmg

      - name: Upload app artifact
        uses: actions/upload-artifact@v4
        with:
          name: PullRead-app
          path: PullReadTray/artifacts/Pull Read.app
          retention-days: 30

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: PullRead-dmg
          path: PullReadTray/artifacts/PullRead.dmg
          retention-days: 30

      - name: Clean up keychain
        if: always() && env.HAS_SIGNING_CERT == 'true'
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

  release:
    needs: build-and-test
    if: always() && needs.build-and-test.result == 'success' && (github.event.inputs.create_release == 'true' || startsWith(github.ref, 'refs/tags/v'))
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download DMG artifact
        uses: actions/download-artifact@v4
        with:
          name: PullRead-dmg
          path: ./

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: PullRead.dmg
          generate_release_notes: true
          draft: ${{ github.event.inputs.create_release == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Auto-update "latest" release on every push to main
  latest-release:
    needs: build-and-test
    if: always() && needs.build-and-test.result == 'success' && github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download DMG artifact
        uses: actions/download-artifact@v4
        with:
          name: PullRead-dmg
          path: ./

      - name: Update latest release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest
          name: Latest Build
          body: |
            This is the latest build of Pull Read from the main branch.

            The app is self-contained with the CLI binary bundledâ€”no Node.js required.

            **Download:** [PullRead.dmg](https://github.com/${{ github.repository }}/releases/download/latest/PullRead.dmg)

            _Last updated: ${{ github.event.head_commit.timestamp }}_
            _Commit: ${{ github.sha }}_
          files: PullRead.dmg
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
